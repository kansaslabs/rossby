// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rossby.proto

package pb

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Registration: a unary RPC to add a device, add a contact email or phone number, link
// a device to an account, or change the public key of an account. Followed by authorization.
type RegisterRequest struct {
	Device               string     `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	Contacts             []*Contact `protobuf:"bytes,2,rep,name=contacts,proto3" json:"contacts,omitempty"`
	Pubkey               []byte     `protobuf:"bytes,3,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *RegisterRequest) Reset()         { *m = RegisterRequest{} }
func (m *RegisterRequest) String() string { return proto.CompactTextString(m) }
func (*RegisterRequest) ProtoMessage()    {}
func (*RegisterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_901552aaed5aa035, []int{0}
}

func (m *RegisterRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterRequest.Unmarshal(m, b)
}
func (m *RegisterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterRequest.Marshal(b, m, deterministic)
}
func (m *RegisterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterRequest.Merge(m, src)
}
func (m *RegisterRequest) XXX_Size() int {
	return xxx_messageInfo_RegisterRequest.Size(m)
}
func (m *RegisterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterRequest proto.InternalMessageInfo

func (m *RegisterRequest) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *RegisterRequest) GetContacts() []*Contact {
	if m != nil {
		return m.Contacts
	}
	return nil
}

func (m *RegisterRequest) GetPubkey() []byte {
	if m != nil {
		return m.Pubkey
	}
	return nil
}

type RegisterReply struct {
	Success              bool        `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Authorizations       uint32      `protobuf:"varint,2,opt,name=authorizations,proto3" json:"authorizations,omitempty"`
	Errors               *MultiError `protobuf:"bytes,3,opt,name=errors,proto3" json:"errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *RegisterReply) Reset()         { *m = RegisterReply{} }
func (m *RegisterReply) String() string { return proto.CompactTextString(m) }
func (*RegisterReply) ProtoMessage()    {}
func (*RegisterReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_901552aaed5aa035, []int{1}
}

func (m *RegisterReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_RegisterReply.Unmarshal(m, b)
}
func (m *RegisterReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_RegisterReply.Marshal(b, m, deterministic)
}
func (m *RegisterReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_RegisterReply.Merge(m, src)
}
func (m *RegisterReply) XXX_Size() int {
	return xxx_messageInfo_RegisterReply.Size(m)
}
func (m *RegisterReply) XXX_DiscardUnknown() {
	xxx_messageInfo_RegisterReply.DiscardUnknown(m)
}

var xxx_messageInfo_RegisterReply proto.InternalMessageInfo

func (m *RegisterReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *RegisterReply) GetAuthorizations() uint32 {
	if m != nil {
		return m.Authorizations
	}
	return 0
}

func (m *RegisterReply) GetErrors() *MultiError {
	if m != nil {
		return m.Errors
	}
	return nil
}

// Authorization: a unary RPC that is a response to a side channel. On registration,
// Rossby sends an authorization code to the phone or email address associated with the
// account. The user sends this code back in the authorization RPC and gets a unique
// token that they can use to authenticate messages to the server with.
type AuthorizeRequest struct {
	Device               string   `protobuf:"bytes,1,opt,name=device,proto3" json:"device,omitempty"`
	Authorization        string   `protobuf:"bytes,2,opt,name=authorization,proto3" json:"authorization,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthorizeRequest) Reset()         { *m = AuthorizeRequest{} }
func (m *AuthorizeRequest) String() string { return proto.CompactTextString(m) }
func (*AuthorizeRequest) ProtoMessage()    {}
func (*AuthorizeRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_901552aaed5aa035, []int{2}
}

func (m *AuthorizeRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthorizeRequest.Unmarshal(m, b)
}
func (m *AuthorizeRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthorizeRequest.Marshal(b, m, deterministic)
}
func (m *AuthorizeRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeRequest.Merge(m, src)
}
func (m *AuthorizeRequest) XXX_Size() int {
	return xxx_messageInfo_AuthorizeRequest.Size(m)
}
func (m *AuthorizeRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeRequest.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeRequest proto.InternalMessageInfo

func (m *AuthorizeRequest) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *AuthorizeRequest) GetAuthorization() string {
	if m != nil {
		return m.Authorization
	}
	return ""
}

type AuthorizeReply struct {
	Success              bool        `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Token                string      `protobuf:"bytes,2,opt,name=token,proto3" json:"token,omitempty"`
	Inbox                string      `protobuf:"bytes,3,opt,name=inbox,proto3" json:"inbox,omitempty"`
	Errors               *MultiError `protobuf:"bytes,4,opt,name=errors,proto3" json:"errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *AuthorizeReply) Reset()         { *m = AuthorizeReply{} }
func (m *AuthorizeReply) String() string { return proto.CompactTextString(m) }
func (*AuthorizeReply) ProtoMessage()    {}
func (*AuthorizeReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_901552aaed5aa035, []int{3}
}

func (m *AuthorizeReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AuthorizeReply.Unmarshal(m, b)
}
func (m *AuthorizeReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AuthorizeReply.Marshal(b, m, deterministic)
}
func (m *AuthorizeReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthorizeReply.Merge(m, src)
}
func (m *AuthorizeReply) XXX_Size() int {
	return xxx_messageInfo_AuthorizeReply.Size(m)
}
func (m *AuthorizeReply) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthorizeReply.DiscardUnknown(m)
}

var xxx_messageInfo_AuthorizeReply proto.InternalMessageInfo

func (m *AuthorizeReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *AuthorizeReply) GetToken() string {
	if m != nil {
		return m.Token
	}
	return ""
}

func (m *AuthorizeReply) GetInbox() string {
	if m != nil {
		return m.Inbox
	}
	return ""
}

func (m *AuthorizeReply) GetErrors() *MultiError {
	if m != nil {
		return m.Errors
	}
	return nil
}

// Add Contacts: this RPC is designed to fetch the public key of another user when the
// client supplies an authorized phone number or email. This can be a bit tricky, and
// the server has to manage whether or not users are allowed to be discovered
// automatically or not.
type ContactRequest struct {
	Contacts             []*Contact `protobuf:"bytes,2,rep,name=contacts,proto3" json:"contacts,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *ContactRequest) Reset()         { *m = ContactRequest{} }
func (m *ContactRequest) String() string { return proto.CompactTextString(m) }
func (*ContactRequest) ProtoMessage()    {}
func (*ContactRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_901552aaed5aa035, []int{4}
}

func (m *ContactRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ContactRequest.Unmarshal(m, b)
}
func (m *ContactRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ContactRequest.Marshal(b, m, deterministic)
}
func (m *ContactRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContactRequest.Merge(m, src)
}
func (m *ContactRequest) XXX_Size() int {
	return xxx_messageInfo_ContactRequest.Size(m)
}
func (m *ContactRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_ContactRequest.DiscardUnknown(m)
}

var xxx_messageInfo_ContactRequest proto.InternalMessageInfo

func (m *ContactRequest) GetContacts() []*Contact {
	if m != nil {
		return m.Contacts
	}
	return nil
}

// TODO: also respond with contact profile
type ContactReply struct {
	Success              bool        `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Pubkey               string      `protobuf:"bytes,2,opt,name=pubkey,proto3" json:"pubkey,omitempty"`
	Errors               *MultiError `protobuf:"bytes,3,opt,name=errors,proto3" json:"errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *ContactReply) Reset()         { *m = ContactReply{} }
func (m *ContactReply) String() string { return proto.CompactTextString(m) }
func (*ContactReply) ProtoMessage()    {}
func (*ContactReply) Descriptor() ([]byte, []int) {
	return fileDescriptor_901552aaed5aa035, []int{5}
}

func (m *ContactReply) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ContactReply.Unmarshal(m, b)
}
func (m *ContactReply) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ContactReply.Marshal(b, m, deterministic)
}
func (m *ContactReply) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ContactReply.Merge(m, src)
}
func (m *ContactReply) XXX_Size() int {
	return xxx_messageInfo_ContactReply.Size(m)
}
func (m *ContactReply) XXX_DiscardUnknown() {
	xxx_messageInfo_ContactReply.DiscardUnknown(m)
}

var xxx_messageInfo_ContactReply proto.InternalMessageInfo

func (m *ContactReply) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *ContactReply) GetPubkey() string {
	if m != nil {
		return m.Pubkey
	}
	return ""
}

func (m *ContactReply) GetErrors() *MultiError {
	if m != nil {
		return m.Errors
	}
	return nil
}

// Fetch Messages: this RPC is a one-off request to fetch all the messages corresponding
// to the device. This RPC is used in a periodic fashion, whereas the Chat streaming RPC
// is used to deliver messages to users who are currently online.
type FetchRequest struct {
	Device               string   `protobuf:"bytes,2,opt,name=device,proto3" json:"device,omitempty"`
	Inbox                string   `protobuf:"bytes,3,opt,name=inbox,proto3" json:"inbox,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *FetchRequest) Reset()         { *m = FetchRequest{} }
func (m *FetchRequest) String() string { return proto.CompactTextString(m) }
func (*FetchRequest) ProtoMessage()    {}
func (*FetchRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_901552aaed5aa035, []int{6}
}

func (m *FetchRequest) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_FetchRequest.Unmarshal(m, b)
}
func (m *FetchRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_FetchRequest.Marshal(b, m, deterministic)
}
func (m *FetchRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_FetchRequest.Merge(m, src)
}
func (m *FetchRequest) XXX_Size() int {
	return xxx_messageInfo_FetchRequest.Size(m)
}
func (m *FetchRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_FetchRequest.DiscardUnknown(m)
}

var xxx_messageInfo_FetchRequest proto.InternalMessageInfo

func (m *FetchRequest) GetDevice() string {
	if m != nil {
		return m.Device
	}
	return ""
}

func (m *FetchRequest) GetInbox() string {
	if m != nil {
		return m.Inbox
	}
	return ""
}

// Deliver Messages: this RPC is a one-off request to deliver a set of messages. This RPC
// is used in an asynchronous fashion when a Chat streaming RPC pipe does not exist.
type DeliverResponse struct {
	Success              bool        `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	Deliveries           uint32      `protobuf:"varint,2,opt,name=deliveries,proto3" json:"deliveries,omitempty"`
	Errors               *MultiError `protobuf:"bytes,3,opt,name=errors,proto3" json:"errors,omitempty"`
	XXX_NoUnkeyedLiteral struct{}    `json:"-"`
	XXX_unrecognized     []byte      `json:"-"`
	XXX_sizecache        int32       `json:"-"`
}

func (m *DeliverResponse) Reset()         { *m = DeliverResponse{} }
func (m *DeliverResponse) String() string { return proto.CompactTextString(m) }
func (*DeliverResponse) ProtoMessage()    {}
func (*DeliverResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_901552aaed5aa035, []int{7}
}

func (m *DeliverResponse) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_DeliverResponse.Unmarshal(m, b)
}
func (m *DeliverResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_DeliverResponse.Marshal(b, m, deterministic)
}
func (m *DeliverResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_DeliverResponse.Merge(m, src)
}
func (m *DeliverResponse) XXX_Size() int {
	return xxx_messageInfo_DeliverResponse.Size(m)
}
func (m *DeliverResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_DeliverResponse.DiscardUnknown(m)
}

var xxx_messageInfo_DeliverResponse proto.InternalMessageInfo

func (m *DeliverResponse) GetSuccess() bool {
	if m != nil {
		return m.Success
	}
	return false
}

func (m *DeliverResponse) GetDeliveries() uint32 {
	if m != nil {
		return m.Deliveries
	}
	return 0
}

func (m *DeliverResponse) GetErrors() *MultiError {
	if m != nil {
		return m.Errors
	}
	return nil
}

func init() {
	proto.RegisterType((*RegisterRequest)(nil), "pb.RegisterRequest")
	proto.RegisterType((*RegisterReply)(nil), "pb.RegisterReply")
	proto.RegisterType((*AuthorizeRequest)(nil), "pb.AuthorizeRequest")
	proto.RegisterType((*AuthorizeReply)(nil), "pb.AuthorizeReply")
	proto.RegisterType((*ContactRequest)(nil), "pb.ContactRequest")
	proto.RegisterType((*ContactReply)(nil), "pb.ContactReply")
	proto.RegisterType((*FetchRequest)(nil), "pb.FetchRequest")
	proto.RegisterType((*DeliverResponse)(nil), "pb.DeliverResponse")
}

func init() { proto.RegisterFile("rossby.proto", fileDescriptor_901552aaed5aa035) }

var fileDescriptor_901552aaed5aa035 = []byte{
	// 456 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x54, 0x4d, 0x6f, 0xd3, 0x40,
	0x10, 0x8d, 0xd3, 0x36, 0x1f, 0x13, 0xc7, 0x2d, 0x43, 0x85, 0x22, 0x1f, 0x50, 0xb4, 0x42, 0xc5,
	0x5c, 0x22, 0x08, 0x48, 0x08, 0x89, 0x0b, 0x2a, 0x70, 0x43, 0x42, 0xfb, 0x0f, 0x6c, 0x77, 0xd4,
	0x98, 0x86, 0xac, 0xf1, 0xae, 0x2b, 0xcc, 0x81, 0xbf, 0xc4, 0x5f, 0x44, 0xfb, 0xe1, 0xc4, 0x36,
	0xc8, 0xcd, 0xf1, 0xbd, 0x9d, 0xaf, 0xf7, 0x66, 0x6c, 0xf0, 0x0b, 0x21, 0x65, 0x52, 0xad, 0xf2,
	0x42, 0x28, 0x81, 0xc3, 0x3c, 0x09, 0x7d, 0x2a, 0x0a, 0x51, 0x48, 0xcb, 0x84, 0xc1, 0x77, 0x92,
	0x32, 0xbe, 0xa5, 0x3d, 0x4e, 0xc5, 0x4e, 0xc5, 0xa9, 0x72, 0x98, 0x7d, 0x83, 0x73, 0x4e, 0xb7,
	0x99, 0x54, 0x54, 0x70, 0xfa, 0x51, 0x92, 0x54, 0xf8, 0x04, 0x46, 0x37, 0x74, 0x9f, 0xa5, 0xb4,
	0xf0, 0x96, 0x5e, 0x34, 0xe5, 0x0e, 0xe1, 0x73, 0x98, 0xd4, 0xc9, 0x8b, 0xe1, 0xf2, 0x24, 0x9a,
	0xad, 0x67, 0xab, 0x3c, 0x59, 0x5d, 0x5b, 0x8e, 0xef, 0x1f, 0x75, 0x81, 0xbc, 0x4c, 0xee, 0xa8,
	0x5a, 0x9c, 0x2c, 0xbd, 0xc8, 0xe7, 0x0e, 0xb1, 0x0a, 0xe6, 0x87, 0x5e, 0xf9, 0xb6, 0xc2, 0x05,
	0x8c, 0x65, 0x99, 0xa6, 0x24, 0xa5, 0x69, 0x35, 0xe1, 0x35, 0xc4, 0x2b, 0x08, 0xe2, 0x52, 0x6d,
	0x44, 0x91, 0xfd, 0x8a, 0x55, 0x26, 0x76, 0xba, 0xa3, 0x17, 0xcd, 0x79, 0x87, 0xc5, 0x2b, 0x18,
	0x59, 0xb9, 0xa6, 0xd5, 0x6c, 0x1d, 0xe8, 0x89, 0xbe, 0x94, 0x5b, 0x95, 0x7d, 0xd2, 0x34, 0x77,
	0xaf, 0xec, 0x2b, 0x5c, 0x7c, 0x70, 0x99, 0xf4, 0x90, 0xce, 0x67, 0x30, 0x6f, 0x75, 0x31, 0xad,
	0xa7, 0xbc, 0x4d, 0xb2, 0xdf, 0x10, 0x34, 0x2a, 0xf6, 0xab, 0xb9, 0x84, 0x33, 0x25, 0xee, 0xa8,
	0xae, 0x64, 0x81, 0x66, 0xb3, 0x5d, 0x22, 0x7e, 0x9a, 0xd1, 0xa7, 0xdc, 0x82, 0x86, 0xa2, 0xd3,
	0x5e, 0x45, 0xef, 0x20, 0xa8, 0x9d, 0x77, 0x7a, 0x8e, 0xdd, 0x0f, 0xdb, 0x80, 0xbf, 0x4f, 0xed,
	0x1f, 0xfc, 0xb0, 0x49, 0x3b, 0xb9, 0x43, 0x47, 0xdb, 0xfe, 0x1e, 0xfc, 0xcf, 0xa4, 0xd2, 0xcd,
	0xbf, 0x96, 0x0f, 0x5b, 0x96, 0xff, 0xd7, 0x0a, 0x26, 0xe1, 0xfc, 0x23, 0x6d, 0xb3, 0x7b, 0x7d,
	0x2e, 0x32, 0x17, 0x3b, 0x49, 0x3d, 0xa3, 0x3e, 0x05, 0xb8, 0xb1, 0xc1, 0x19, 0xd5, 0xd7, 0xd2,
	0x60, 0x8e, 0x1d, 0x79, 0xfd, 0x67, 0x08, 0x23, 0x6e, 0xbe, 0x29, 0x7c, 0x03, 0x93, 0xfa, 0x5e,
	0xf1, 0xb1, 0x0e, 0xef, 0x7c, 0x29, 0xe1, 0xa3, 0x36, 0x99, 0x6f, 0x2b, 0x36, 0xc0, 0xb7, 0x30,
	0xdd, 0x1f, 0x06, 0x5e, 0xea, 0x88, 0xee, 0xe5, 0x85, 0xd8, 0x61, 0x6d, 0xe2, 0x2b, 0x18, 0xbb,
	0xb5, 0x20, 0x36, 0x17, 0xe7, 0x92, 0x2e, 0x5a, 0x9c, 0x4d, 0x79, 0x01, 0x67, 0xc6, 0x5f, 0x34,
	0x8f, 0x4d, 0xab, 0x43, 0xdf, 0xe8, 0x73, 0x1f, 0x3f, 0x1b, 0xe0, 0x0a, 0xc6, 0xce, 0x4c, 0x6c,
	0x3d, 0x85, 0x46, 0x59, 0xc7, 0x67, 0x36, 0xc0, 0x08, 0x4e, 0xaf, 0x37, 0xb1, 0xea, 0x04, 0x77,
	0xaa, 0x46, 0xde, 0x4b, 0x2f, 0x19, 0x99, 0x3f, 0xc9, 0xeb, 0xbf, 0x01, 0x00, 0x00, 0xff, 0xff,
	0x2c, 0xd0, 0x41, 0xa2, 0x8b, 0x04, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RossbyClient is the client API for Rossby service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RossbyClient interface {
	Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error)
	Authorize(ctx context.Context, in *AuthorizeRequest, opts ...grpc.CallOption) (*AuthorizeReply, error)
	Contact(ctx context.Context, in *ContactRequest, opts ...grpc.CallOption) (*ContactReply, error)
	Fetch(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (*Messages, error)
	Deliver(ctx context.Context, in *Messages, opts ...grpc.CallOption) (*DeliverResponse, error)
	// TODO: is this a single bidirectional stream or two unidirectional streams?
	Chat(ctx context.Context, opts ...grpc.CallOption) (Rossby_ChatClient, error)
}

type rossbyClient struct {
	cc *grpc.ClientConn
}

func NewRossbyClient(cc *grpc.ClientConn) RossbyClient {
	return &rossbyClient{cc}
}

func (c *rossbyClient) Register(ctx context.Context, in *RegisterRequest, opts ...grpc.CallOption) (*RegisterReply, error) {
	out := new(RegisterReply)
	err := c.cc.Invoke(ctx, "/pb.Rossby/Register", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rossbyClient) Authorize(ctx context.Context, in *AuthorizeRequest, opts ...grpc.CallOption) (*AuthorizeReply, error) {
	out := new(AuthorizeReply)
	err := c.cc.Invoke(ctx, "/pb.Rossby/Authorize", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rossbyClient) Contact(ctx context.Context, in *ContactRequest, opts ...grpc.CallOption) (*ContactReply, error) {
	out := new(ContactReply)
	err := c.cc.Invoke(ctx, "/pb.Rossby/Contact", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rossbyClient) Fetch(ctx context.Context, in *FetchRequest, opts ...grpc.CallOption) (*Messages, error) {
	out := new(Messages)
	err := c.cc.Invoke(ctx, "/pb.Rossby/Fetch", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rossbyClient) Deliver(ctx context.Context, in *Messages, opts ...grpc.CallOption) (*DeliverResponse, error) {
	out := new(DeliverResponse)
	err := c.cc.Invoke(ctx, "/pb.Rossby/Deliver", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rossbyClient) Chat(ctx context.Context, opts ...grpc.CallOption) (Rossby_ChatClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Rossby_serviceDesc.Streams[0], "/pb.Rossby/Chat", opts...)
	if err != nil {
		return nil, err
	}
	x := &rossbyChatClient{stream}
	return x, nil
}

type Rossby_ChatClient interface {
	Send(*Messages) error
	Recv() (*Messages, error)
	grpc.ClientStream
}

type rossbyChatClient struct {
	grpc.ClientStream
}

func (x *rossbyChatClient) Send(m *Messages) error {
	return x.ClientStream.SendMsg(m)
}

func (x *rossbyChatClient) Recv() (*Messages, error) {
	m := new(Messages)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// RossbyServer is the server API for Rossby service.
type RossbyServer interface {
	Register(context.Context, *RegisterRequest) (*RegisterReply, error)
	Authorize(context.Context, *AuthorizeRequest) (*AuthorizeReply, error)
	Contact(context.Context, *ContactRequest) (*ContactReply, error)
	Fetch(context.Context, *FetchRequest) (*Messages, error)
	Deliver(context.Context, *Messages) (*DeliverResponse, error)
	// TODO: is this a single bidirectional stream or two unidirectional streams?
	Chat(Rossby_ChatServer) error
}

func RegisterRossbyServer(s *grpc.Server, srv RossbyServer) {
	s.RegisterService(&_Rossby_serviceDesc, srv)
}

func _Rossby_Register_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(RegisterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RossbyServer).Register(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Rossby/Register",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RossbyServer).Register(ctx, req.(*RegisterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rossby_Authorize_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AuthorizeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RossbyServer).Authorize(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Rossby/Authorize",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RossbyServer).Authorize(ctx, req.(*AuthorizeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rossby_Contact_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ContactRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RossbyServer).Contact(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Rossby/Contact",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RossbyServer).Contact(ctx, req.(*ContactRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rossby_Fetch_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(FetchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RossbyServer).Fetch(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Rossby/Fetch",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RossbyServer).Fetch(ctx, req.(*FetchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rossby_Deliver_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Messages)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RossbyServer).Deliver(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/pb.Rossby/Deliver",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RossbyServer).Deliver(ctx, req.(*Messages))
	}
	return interceptor(ctx, in, info, handler)
}

func _Rossby_Chat_Handler(srv interface{}, stream grpc.ServerStream) error {
	return srv.(RossbyServer).Chat(&rossbyChatServer{stream})
}

type Rossby_ChatServer interface {
	Send(*Messages) error
	Recv() (*Messages, error)
	grpc.ServerStream
}

type rossbyChatServer struct {
	grpc.ServerStream
}

func (x *rossbyChatServer) Send(m *Messages) error {
	return x.ServerStream.SendMsg(m)
}

func (x *rossbyChatServer) Recv() (*Messages, error) {
	m := new(Messages)
	if err := x.ServerStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

var _Rossby_serviceDesc = grpc.ServiceDesc{
	ServiceName: "pb.Rossby",
	HandlerType: (*RossbyServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Register",
			Handler:    _Rossby_Register_Handler,
		},
		{
			MethodName: "Authorize",
			Handler:    _Rossby_Authorize_Handler,
		},
		{
			MethodName: "Contact",
			Handler:    _Rossby_Contact_Handler,
		},
		{
			MethodName: "Fetch",
			Handler:    _Rossby_Fetch_Handler,
		},
		{
			MethodName: "Deliver",
			Handler:    _Rossby_Deliver_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Chat",
			Handler:       _Rossby_Chat_Handler,
			ServerStreams: true,
			ClientStreams: true,
		},
	},
	Metadata: "rossby.proto",
}
